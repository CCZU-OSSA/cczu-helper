import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:cczu_helper/models/db_models.dart';

/// 全平台 Supabase 配置与简易封装
/// 请在应用启动时调用 `initSupabase()`。

// Read Supabase configuration from compile-time environment variables.
// Pass via `--dart-define=SUPABASE_URL=... --dart-define=SUPABASE_ANON_KEY=...` when building,
// or keep the defaults for backward compatibility.
const _supabaseUrl = String.fromEnvironment(
  'SUPABASE_URL',
  defaultValue: 'https://udrykrwyvnvmavbrdnnm.supabase.co',
);
const _supabaseAnonKey = String.fromEnvironment(
  'SUPABASE_ANON_KEY',
  defaultValue: '',
);

Future<void> initSupabase() async {
  if (_supabaseAnonKey.isEmpty) {
    // If no anon key supplied at build time, skip initialization.
    // Callers should wrap `initSupabase()` in try/catch if they require Supabase.
    return;
  }

  await Supabase.initialize(
    url: _supabaseUrl,
    anonKey: _supabaseAnonKey,
  );
}

SupabaseClient get supabase => Supabase.instance.client;

class SupabaseService {
  /// 获取帖子（分页）
  static Future<List<PostModel>> getPosts({
    int page = 1,
    int pageSize = 20,
  }) async {
    final limit = pageSize;
    final offset = (page - 1) * pageSize;
    final userId = supabase.auth.currentUser?.id;

    // Call RPC to fetch posts with like_count and is_liked for current user (if any)
    final params = <String, dynamic>{'p_limit': limit, 'p_offset': offset, 'p_user': userId};
    final res = await supabase.rpc('get_posts_with_likes', params: params) as List?;
    if (res == null) return [];
    return res.map((e) => PostModel.fromMap(e as Map<String, dynamic>)).toList();
  }

  static Future<PostModel?> createPost(String title, String content,
      {required int categoryId, String? userId, PostStatus status = PostStatus.available, String? imageUrls, double? price, bool? isAnonymous}) async {
    final now = DateTime.now().toUtc().toIso8601String();
    final payload = {
      'title': title,
      'content': content,
      'category_id': categoryId,
      'user_id': userId,
      'status': postStatusToString(status),
      'image_urls': imageUrls,
      'price': price,
      'is_anonymous': isAnonymous,
      'created_at': now,
    };
    final resp = await supabase.from('posts').insert(payload).select().maybeSingle();
    if (resp == null) return null;
    return PostModel.fromMap(resp as Map<String, dynamic>);
  }

  static Future<List<CommentModel>> getComments(String postId) async {
    final res = await supabase
        .from('comments')
        .select()
        .eq('post_id', postId)
        .order('created_at', ascending: true) as List;
    return res.map((e) => CommentModel.fromMap(e as Map<String, dynamic>)).toList();
  }

  static Future<CommentModel?> createComment(String postId, String content,
      {String? userId, bool? isAnonymous, String? parentCommentId}) async {
    final now = DateTime.now().toUtc().toIso8601String();
    final payload = {
      'post_id': postId,
      'content': content,
      'user_id': userId,
      'is_anonymous': isAnonymous,
      'parent_comment_id': parentCommentId,
      'created_at': now,
    };
    final resp = await supabase.from('comments').insert(payload).select().maybeSingle();
    if (resp == null) return null;
    return CommentModel.fromMap(resp as Map<String, dynamic>);
  }

  static Future<bool> deletePost(String postId) async {
    await supabase.from('posts').delete().eq('id', postId);
    await supabase.from('comments').delete().eq('post_id', postId);
    return true;
  }

  /// 编辑帖子（部分字段可选）
  static Future<PostModel?> editPost(String postId,
      {String? title,
      String? content,
      int? categoryId,
      double? price,
      PostStatus? status}) async {
    final payload = <String, dynamic>{};
    if (title != null) payload['title'] = title;
    if (content != null) payload['content'] = content;
    if (categoryId != null) payload['category_id'] = categoryId;
    if (price != null) payload['price'] = price;
    if (status != null) payload['status'] = postStatusToString(status);

    final resp = await supabase.from('posts').update(payload).eq('id', postId).select().maybeSingle();
    if (resp == null) return null;
    return PostModel.fromMap(resp as Map<String, dynamic>);
  }

  /// 点赞/取消点赞（简单实现：插入或删除 likes 表中的记录）
  static Future<bool> toggleLike(String postId, String userId, bool liked) async {
    if (liked) {
      // create like (id will be generated by DB)
      await supabase.from('likes').insert({'post_id': postId, 'user_id': userId}).maybeSingle();
      return true;
    } else {
      await supabase.from('likes').delete().eq('post_id', postId).eq('user_id', userId);
      return true;
    }
  }

  /// 批量获取 posts 的点赞计数，返回 `Map<String,int>`（postId -> count）
  static Future<Map<String, int>> getLikeCounts(List<String> postIds) async {
    if (postIds.isEmpty) return {};
    final res = await supabase
        .from('likes')
        .select('post_id')
        .in_('post_id', postIds) as List;
    final Map<String, int> counts = {};
    for (final item in res) {
      final pid = (item as Map<String, dynamic>)['post_id'] as String;
      counts[pid] = (counts[pid] ?? 0) + 1;
    }
    return counts;
  }

  /// 获取指定用户在一组帖子中的点赞状态，返回已点赞的 postId 集合
  static Future<Set<String>> getLikedPostIdsForUser(String userId, List<String> postIds) async {
    if (userId.isEmpty || postIds.isEmpty) return {};
    final res = await supabase
        .from('likes')
        .select('post_id')
        .eq('user_id', userId)
        .in_('post_id', postIds) as List;
    final Set<String> set = {};
    for (final item in res) {
      final pid = (item as Map<String, dynamic>)['post_id'] as String;
      set.add(pid);
    }
    return set;
  }

  /// 获取活动的横幅图片（若无返回 null）。查询表 `banners` 的 `image_url` 字段，要求 `active = true`。
  /// 如果服务器不存在该表或查询失败，方法会返回 null。
  static Future<String?> getActiveBanner() async {
    try {
      final res = await supabase
          .from('banners')
          .select('image_url')
          .eq('active', true)
          .order('created_at', ascending: false)
          .limit(1) as List?;
      if (res == null || res.isEmpty) return null;
      final item = res.first as Map<String, dynamic>;
      final url = item['image_url'] as String?;
      return (url != null && url.isNotEmpty) ? url : null;
    } catch (_) {
      return null;
    }
  }
}
